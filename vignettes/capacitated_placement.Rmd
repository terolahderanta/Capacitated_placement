---
title: "Capacitated Placement"
author: "Tero Lähderanta, Lauri Lovén, Leena Ruha"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Capacitated Placement}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 6,
  fig.height = 4,  
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides a tutorial on main functionality of the `rpack` package.

## Libraries

First, load the necessary libraries. In addition to the `rpack` package, we use 
`tidyverse` and `dplyr` for sample data manipulation and  `ggplot2` for plotting.

```{r, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(rpack)
library(tidyverse)
library(LaplacesDemon)
library(Matrix)
library(plotly)
c_col = c("blue","red","green","orange","hotpink","cyan","yellowgreen","purple",
          "chocolate","darkred","yellow3","darkgreen","bisque4","magenta",
          "royalblue","tomato4","steelblue1",
          "seagreen4","orangered","darkblue","khaki3","lavender","deeppink2",
          "coral3","beige","brown4","indianred1","lightgreen","orchid")
```


## Simulated data 

Let's set up some data to be clustered. 

```{r data, include=TRUE, echo = TRUE}

set.seed(112)

# Generating 200 points from mixture of 10 normal distributions.
test_dat <- simulate_normal_mixture(n = 200, k = 10)

# Ids in interactive plot
id <-  1:nrow(test_dat)

plot_sim <- ggplot(data = test_dat, aes(x = x, y = y, size = w, label = id)) +
  geom_point() +
  scale_size(range = c(2, 6)) +  # Scale objects sizes
  guides(
    color = guide_legend(        # Point size in legend
      override.aes = list(size=5)
    )
  ) +
  labs(x = "x", y = "y", title = "Unclustered data") +
  theme(
    legend.position = "right",            # Legend position and removing ticks from axis
    axis.text.x = ggplot2::element_blank(),
    axis.text.y = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_blank()
  )

ggplotly(plot_sim, tooltip = c("id", "w"))

```

Bigger datasets take a bit longer to cluster. To get a hang of the required processing times, you could try also the following sets:

```{r bigger_data, echo = TRUE, include = TRUE}

set.seed(112)

# Generating 500 points from mixture of 20 Laplace distributions.
test_dat2 <- simulate_laplace_mixture(n = 500, k = 20)

# Generating 1000 points from mixture of 25 normal distributions.
test_dat3 <- simulate_normal_mixture(n = 1000, k = 25)

```



## Clustering with uniform prior

First, cluster the data into $k=10$ clusters with a uniform prior for the cluster weights. In other words, 
we let the total weights of clusters vary uniformly within a given range. We set the
range as $mean(w) \pm 100 $.


```{r uniform_clustering, include=TRUE, echo = TRUE}

# Number of clusters
k <- 10

# Mean
pr_mean <- round(sum(test_dat$w) / k)

# Max radius for prior
pr_width <- 100

# Lower und upper limit for cluster size
L <- (pr_mean - pr_width)
U <- (pr_mean + pr_width)

# Alternaring algorithm
clust <- alt_alg(
  coords = dplyr::select(test_dat, x, y),
  weights = test_dat$w,
  N = 2,
  k = k,
  range = c(L, U),
  place_to_point = FALSE
)

# Save the results of the clustering.
test_dat$cl <- clust$clusters
mu <- clust$centers
obj_min <- clust$obj
```

Plot the clusters with `plot_clusters`.
```{r uniform_clusterplot, echo=TRUE, include=TRUE}
plot_clusters(
  coords = test_dat[,1:2],
  weights = test_dat$w,
  clusters = test_dat$cl,
  mu = mu,
  title = paste("Capacitated clustering, k = ", k, sep = ""),
  subtitle = paste("Uniform prior in [", L, ", ", U, "] on cluster sizes", sep = "")
)
```

## Clustering with limitations to center locations and adding outgroup for the data points.

Similarly, cluster the data into $k=10$ clusters, but limit the cluster heads to chosen from the set of data points. In addition, add outgroup for the data points. Outgroup consists of points that can be seen as outliers from other points and are not allocated to any of the clusters. 

```{r uniform_clustering_out, include=TRUE, echo = TRUE}

# Number of clusters
k <- 10

# Mean
pr_mean <- round(sum(test_dat$w) / k)

# Max radius for prior
pr_width <- 100

# Lower und upper limit for cluster size
L <- (pr_mean - pr_width)
U <- (pr_mean + pr_width)

# Outgroup parameter lambda, smaller value --> more outliers
lambda1 <- 0.016

# Alternaring algorithm
clust2 <- alt_alg(
  coords = dplyr::select(test_dat, x, y),
  weights = test_dat$w,
  N = 2,
  k = k,
  range = c(L, U),
  place_to_point = TRUE, # Cluster heads is chosen from the data points
  lambda = lambda1
)

```

Plot the clusters. Outgroup points are labeled as "NA".
```{r uniform_clusterplot_out, echo=TRUE, include=TRUE}
plot_clusters(
  coords = test_dat[,1:2],
  weights = test_dat$w,
  clusters = clust2$clusters,
  mu = clust2$centers,
  title = paste("Capacitated clustering, k = ", k, sep = ""),
  subtitle = paste("Uniform prior in [", L, ", ", U, "] on cluster sizes", sep = "")
)
```

## Clustering with different distance metric.

Once again, cluster the data into $k=10$ clusters, but calculate the distance between points as Euclidean distance instead of default squared Euclidean distance. Euclidean distance measure minimizes the physical distance between points and the center in a cluster, while squared Euclidean distance forms more spherical-like clusters.

```{r uniform_clustering_euc_dist, include=TRUE, echo = TRUE}

# Number of clusters
k <- 10

# Mean
pr_mean <- round(sum(test_dat$w) / k)

# Max radius for prior
pr_width <- 100

# Lower und upper limit for cluster size
L <- (pr_mean - pr_width)
U <- (pr_mean + pr_width)

# Alternaring algorithm
clust3 <- alt_alg(
  coords = dplyr::select(test_dat, x, y),
  weights = test_dat$w,
  N = 2,
  k = k,
  range = c(L, U),
  place_to_point = TRUE,
  d = euc_dist # Input for distance metric is in a form of a function.  
)

```

Plot the clusters.
```{r uniform_clusterplot_euc_dist_plot, echo=TRUE, include=TRUE}
plot_clusters(
  coords = test_dat[,1:2],
  weights = test_dat$w,
  clusters = clust3$clusters,
  mu = clust3$centers,
  title = paste("Capacitated clustering, k = ", k, sep = ""),
  subtitle = paste("Uniform prior in [", L, ", ", U, "] on cluster sizes", sep = "")
)
```

## Clustering with pre-determined center locations (MISSING)

Previously we allowed cluster heads to be one of the demand points. In this example we give all the possible cluster head locations as an input to the algorithm. 

```{r uniform_clustering_predet_loc, include=TRUE, echo = TRUE}

# Pre-determined cluster head locations
predet_loc <- dplyr::tibble(x = rep(seq(from = -10, to = 10, by = 4), times = 6),
                     y = rep(seq(from = -10, to = 10, by = 4), each = 6))

# Plotting the demand points. Red points refer to predetermined center locations
ggplot() +
  geom_point(data = test_dat, aes(x = x, y = y, size = w)) +
  scale_size(range = c(2, 6)) +  # Scale objects sizes
  guides(
    color = guide_legend(        # Point size in legend
      override.aes = list(size=5)
    )
  ) +
  labs(x = "x", y = "y", title = "Unclustered data") +
  theme(
    legend.position = "right",            # Legend position and removing ticks from axis
    axis.text.x = ggplot2::element_blank(),
    axis.text.y = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_blank()
  ) + 
  geom_point(data = predet_loc,
             mapping = aes(x = x, y = y),
             shape = 18,
             col = "red",
             size = 5)

# Number of clusters
k <- 10

# Mean
pr_mean <- round(sum(test_dat$w) / k)

# Max radius for prior
pr_width <- 1000

# Lower und upper limit for cluster size
L <- (pr_mean - pr_width)
U <- (pr_mean + pr_width)

# Alternaring algorithm
#clust4 <- alt_alg(
#  coords = dplyr::select(test_dat, x, y),
#  weights = test_dat$w,
#  N = 2,
#  k = k,
#  range = c(L, U),
#  place_to_point = TRUE,
#  predet_locations = predet_loc
#)

```

Plot the clusters. Small crosses refer to all the possible cluster center locations.
```{r clusterplot_predet_loc, echo=TRUE, include=TRUE}
#plot_clusters(
#  coords = test_dat[,1:2],
#  weights = test_dat$w,
#  clusters = clust4$clusters,
#  mu = clust4$centers,
#  title = paste("Capacitated clustering, k = ", k, sep = ""),
#  subtitle = paste("Uniform prior in [", L, ", ", U, "] on cluster sizes", sep = "")
#) + 
#  geom_point(data = predet_loc, 
#             mapping = aes(x = x, y = y),
#             shape = 4)
```

## Clustering with reliability.


```{r uniform_clustering_reliability, include=TRUE, echo = TRUE}

# Number of clusters
k <- 10

# Mean
pr_mean <- round(sum(test_dat$w) / k)

# Max radius for prior
pr_width <- 100

# Lower und upper limit for cluster size
L <- (pr_mean - pr_width)
U <- (pr_mean + pr_width)

# Ids of the points to be assigned to multiple clusters
multip_id <- c(42, 153, 190, 83, 171)

# n-length vector to indicate the number of centers a point is assigned to.
multip_mu <- rep(1, nrow(test_dat))

# Selected points are assigned to two clusters
multip_mu[multip_id] <- 2

# Alternaring algorithm
clust5 <- alt_alg(
  coords = dplyr::select(test_dat, x, y),
  weights = test_dat$w,
  N = 2,
  k = k,
  range = c(L, U),
  place_to_point = TRUE,
  d = euc_dist2,
  multip_mu = multip_mu
)

```

Plot the clusters.
```{r uniform_clusterplot_reliability_plot, echo=TRUE, include=TRUE}
multip_data <- test_dat[multip_id,]

multip_clust <- sapply(X = multip_id,
                       FUN = function(x){which(clust5$assign_frac[x,] == 1)})
multip_data$clust1 <- as.factor(multip_clust[1,])
multip_data$clust2 <- as.factor(multip_clust[2,])


plot_clusters(
  coords = test_dat[,1:2],
  weights = test_dat$w,
  clusters = clust5$clusters,
  mu = clust5$centers,
  title = paste("Capacitated clustering, k = ", k, sep = ""),
  subtitle = paste("Uniform prior in [", L, ", ", U, "] on cluster sizes", sep = "")
) +
  geom_point(data = multip_data,
             mapping = aes(x = x, y = y),
             size = 6,
             color = "black",
             fill = "black",
             shape = 23,
             show.legend = FALSE)+
  geom_point(data = multip_data,
             mapping = aes(x = x, y = y, color = clust1, fill = clust2),
             size = 3,
             shape = 23,
             stroke = 2,
             show.legend = FALSE) + 
  ggplot2::scale_fill_manual(  # Color theme for objects and legend title
      values = c_col[unique(sort(as.numeric(levels(multip_data$clust2))[multip_data$clust2]))],
      #name = "Cluster sizes:",
      #labels = cl_sizes
    )
  
```